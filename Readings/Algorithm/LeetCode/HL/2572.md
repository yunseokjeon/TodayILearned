```Java
/*
문제 : https://leetcode.com/problems/count-the-number-of-square-free-subsets/

https://leetcode.com/problems/count-the-number-of-square-free-subsets/solutions/3206717/bitmask-very-detailed-explaination-titans-plz-skip-code-java/
 */

class Solution {

    int MOD = (int) 1e9 + 7;

    // nums = {3, 4, 4, 5}
    public int squareFreeSubsets(int[] nums) {

        // 1 <= nums.length <= 1000
        // 10 prime
        int[][] dp = new int[1010][1 << 11];
        for (int[] d : dp) {
            Arrays.fill(d, -1);
        }

        // 1 <= nums[i] <= 30
        int[] primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
        int[] numsPrimeMask = new int[nums.length];

        for (int i = 0; i < nums.length; i++) {
            numsPrimeMask[i] = computeMask(nums[i], primes);
        }
        // numsPrimeMask = {4, -1, -1, 8}

        return (dfs(0, 1, numsPrimeMask, dp) - 1 + MOD) % MOD;
    }

    private int dfs(int position, int productMask, int[] numsPrimeMask, int[][] dp) {
        if (position >= numsPrimeMask.length) {
            return 1;
        }

        if (dp[position][productMask] != -1) {
            return dp[position][productMask];
        }

        int answer = dfs(position + 1, productMask, numsPrimeMask, dp);

        /*
        1) productMask가 의미하는 것은 무엇인가?
        2) 왜 (productMask & numsPrimeMask[position]) == 0 이면 중복이 아닌 것인가?
        3) productMask | numsPrimeMask[position] 이 연산이 왜 필요한 것인가?
         */

        if ((productMask & numsPrimeMask[position]) == 0) {
            answer = (answer + dfs(position + 1,
                    productMask | numsPrimeMask[position], numsPrimeMask, dp)) % MOD;
        }

        /*
        position : 3, productMask : 1, numsPrimeMask : [4, -1, -1, 8]
        answer : 1

        1 & 8 -> 0001 & 1000 -> 0

        position : 4, productMask : 9 -> return 1 -> answer : 2
         */

        return dp[position][productMask] = answer;
    }

    private int computeMask(int x, int[] primes) {
        int mask = 0;
        for (int i = 0; i < primes.length; i++) {
            int p = primes[i];
            int count = 0;

            while (x % p == 0) {
                x /= p;
                count++;
            }

            if (count == 0) continue;
            if (count == 1) mask |= (1 << (i + 1));
            // Integer.toBinaryString(-1) -> "11111111111111111111111111111111"
            if (count >= 2) return -1;
        }
        return mask;
    }

    public static void main(String[] args) {
        Solution s = new Solution();
        s.squareFreeSubsets(new int[]{3, 4, 4, 5});
    }
}

/*
하이하이

여기다가 내 생각을 써보겟어

이 문제는 어떻게 풀어야겠다는 결심이 서면, 이 코드를 이해하긴 한결 쉬울꺼야.
일단 내가 생각한 푸는 요령부터 말해볼게.

Square-free subset을 찾는게 중요한데, 완전 탐색으로 모두 찾는 방법 말고는 딱히 떠오르지 않더라고.
해설에서도 dp()를 사용해 완전 탐색을 하는 방법을 쓰고 있더라.

그러면 그 subset을 어떻게 찾느냐. Square-free라는 정의에 따라, 어떤 숫자가 square-free가 되려면
소인수분해를해서 어떤 소인수든 제곱이상으로 표현이 되야된다면 탈락이지. 간단하게 8이나 45 로 생각해보면
이들은 위의 방법으로 square-free가 될 수 없음을 쉽게 검증힐 수 있지.

그러면 subset을 찾을때, 선택된 element들의 곱을 해봤을때, element들 중에 겹치는 소인수가 나오면 안된단 말이지?
왜냐면 겹치는 소인수가 있다는 말은 곱했을때 제곱 이상이 확정으로 나오기 때문이지. 결국 subset에 새 element를 넣을 수 있을지 없을지는,
여태 subset에 줏어담은 애들중에 새 element와 겹치는 소인수가 있으면 탈락 없으면 채택가능이야.

그렇다면 연산을 빠르게 하기 위해선 사전작업이 필요해. 미리 소인수분해를 해두는 거야.
예를들면 element중 하나가 15이다 = 3*5 로 표시, 다른 하나가 35다 = 5*7로 표시하는 거지.
그러면 이걸 어떻게 표현할까? 소수가 2,3,5,7,11,…,29 이니까, 앞에 소수의 지수부터 표시하는거야.
예를 들면 12는 21000…0, 그리고 14는 10010…0 이런식이지. 이 표현 방식을 int[]로 표시해서 {2, 1, 0, 0, 0, … 0} 처럼 표현해도 좋긴 한데,
위의 square-free정의에 따라지수에 2이상이 나온다면 얘는 완전 탈락이네? 그러면 square-free한 애들은 0하고 1로만 표시가 가능해도 충분하고,
square-free하지 않은 애들은 다른 어떤 element랑 곱해도 square-free할 수 없기 때문에 소인수대신 탈락 표시를해두는거야.

이 표시 방법을 효과적으로 표현하기 위해, 여기 해답에선 비트 연산으로 표현을 했어.
가능한 소수가 10개니까, 비트 10개로 표현을 할 수 있겠다고 생각한거지. 2를 비트로 표현할 경우, 100…0 이고, 2*3을 비트로 표현하면 110…0이고,
3*5를 표현하면 011…0이야. 탈락표시는 -1 이고.

그러면 두 element의 곱이 square-free한지는 어떻게 알까? 두 비트표현중에 겹치는 소인수가 있는지 찾으면 되는거야.
그러면 제곱 이상의 소인수가 있다는 뜻이니까. 그럼 탈락 element는 아예 배제해두고,
element끼리의 곱셈을 했을때 겹치는 소인수가 있는지는 어떻게 알 수 있을까? 그게 AND 연산자 (&) 가 할 수 있는 일이야.
겹치는 소인수가 있다면 두 비트표현을 AND해보면 겹치는 비트가 잇을테니 0보다 크겠지! 반면 아무것도 없으면 0이 나올테고.

위의 방법으로 두개의 element가 겹치는 소인수가 없음을 알았어. 그래서 하나의 subset으로 선택을 했어.
이제 다음 element도 subset에 포함할 수 있는지를 확인해야 하는데, 이 경우 이전 두 element랑 각각 두번 비교를 하는 방법이있고,
나머지 한 방법은 처음 두 element를 미리 곱한 소인수분해 정보를 저장해두는 거야. 예를들어 3, 5 가 처음 두 element로 선택받았다면,
그 두개의 곱인 15, 비트표현식으로는 011…0 을 들고다니면서 세번째 네번째 다섯번째 element와 AND연산을 하고 다니면 빠르겠지?
그러면 저 곱을 비트표현식으로 만들기 위해선 element들 끼리 OR연산 (|) 을 하면 원하는 바를 이룰 수 있어. 이게 되는 이유는 AND연산을 미리 해보고
겹치는 비트가 없음(=0) 을 확인했기 때문이야.

1) 그래서 이 문제의 해설에서 productMask라는 것은, 곱 연산(=product) 의 비트표현(=bit mask)라는 것에서 따온 네이밍인거같아.
여태 subset에 포함된 애들의 소인수분해 비트표현을 담고 있어.

2) 위에서 말한것처럼 & 연산은 겹치는 소인수가 있는지 체크하는 용도야. 그렇기 때문에 (productMask & numsPrimeMask[position]) == 0 으로
여태 곱연산 결과와 position에 있는 element를 곱했을때 거듭제곱형태의소인수가 나오는지 검사하는 역할을 할 수 있어

3) 이것또한 위에서 말한것처럼 | 연산으로 여태 곱연산 결과에 새 element의 소인수를 합쳐두는 거야.
그러므로 dp(…., productMask | numsPrimeMask[position],…) 의 의미는 position의 숫자가 subset에 선택되었다는 의미입니다!

혹시 이해가 잘 안가면 그 부분을 다시 물어보세요!
 */

/*
1) square-free integer - 1이 아닌 제곱수를 인수로 갖지 않는 양의 정수
4는 제곱수를 인수로 갖는다. 4 = 2 * 2.

2) 따라서 8이나 45는 square-free integer가 아니다. 왜냐하면 8 = 1 * 2 * 4  = 1 * 8 이다. 45 = 1 * 45 = 5 * 9 = 5 * 3 * 3.
그래서 subset을 찾을 때, 선택된 element들의 곱을 했을 때, element들 중에 '겹치는 소인수'가 나오면 안 된다.
결국 subset에 있는 element 중에 새 element와 겹치는 소인수가 있으면 탈락이고 아니면 담을 수 있다.

3) 빠른 연산을 위해 사전 작업. 가능한 소수가 10개니까, 비트 10개로 표현할 수 있다고 생각한 것.

4) 두 element의 곱이 square-free한지는 어떻게 알까?  두 비트 표현 중에 겹치는 소인수가 있는지 찾으면 된다. 그게 AND(&) 연산자가 하는 일.

5) 두 개의 element가 겹치는 소인수가 없어서 하나의 subset으로 넣은 후에 다음 element를 subset에 포함시켜야 할지 어떻게 판단할까?
선택된 두 element의 곱의 비트 표현식을 가지고 있다가, 새로운 element와 AND 연산을 해서 판단하면 좋을 것이다.
두 element의 곱의 비트 표현식을 위해 OR(|) 연산을 한다.
 */

/*
추가 질문 1)
return (dfs(0, 1, numsPrimeMask, dp) - 1 + MOD) % MOD;
에서 -1은 왜 해주는 것인가요?

추가 질문 2)
if (position >= numsPrimeMask.length) {
    return 1;
}
여기서 왜 1을 반환해 주는 것인가요?
 */

/*
두 질문이 연관되어잇군!

여기서 짜놓은 dfs() 는 모든 element를 훑으면서 1) position에 있는 element를 subset에 포함안하고 position+1로 건너뛰거나
2) 현재 position에 있는 element가 subset에 포함될수 있는 경우에만, subset에 포함시킨후 position+1로 넘어가.
이렇게 계속 훑다보면 position이 무사히 한바퀴를 다 훑었다면 (position >= numsPrimeMask) square-free subset이 하나 완성이 된거잖아?
그래서 한개가 완성되었다는 의미에서 1을 내는거야. 이걸 dfs()를 따라 계속 1이 되는 경우를 찾아서 더해준다면
(answer = (answer + dfs(position + 1, productMask | numsPrimeMask[position], numsPrimeMask, dp))
모든 square-free subset의 개수를 가지게 되겠지!

그럼 여기서 코드상 무조건 position이 한계점을 돌파하면 성공으로 친다고 했는데, 그럼 subset에 아무것도 없으면..?
그래도 코드구조상 1이 리턴이 되어버리는거야. 그래서 마지막에 MOD 이전에 1을 빼주는거!
이런 엣지케이스를 놓치는 것을 라이브코딩에서 방지하기 위해선, 필수적으로 예시를 하나 넣고 로직에 문제가 없는지 체크해보는 단계가 필요해!

아 위의 글을 쓰면서 알아챘는데, 이전 메일에 dfs()를 dp()라고 바꿔썼던거같네.. 찰떡같이 잘 알아들었구만!
 */

/*
1) position : 0 productMask : 1 numsPrimeMask : [4, -1, -1, 8]
dfs(position + 1, productMask, numsPrimeMask, dp)

2) position : 1 productMask : 1
dfs(position + 1, productMask, numsPrimeMask, dp)

3) position : 2 productMask : 1
dfs(position + 1, productMask, numsPrimeMask, dp)

4) position : 3 produtMask : 1
dfs(position + 1, productMask, numsPrimeMask, dp)

5) position : 4 productMask : 1
return 1

6) position : 3 productMask : 1
answer : 1
(answer + dfs(position + 1,
                    productMask | numsPrimeMask[position], numsPrimeMask, dp)) % MOD

7) position : 4 productMask : 9
return 1

8) position : 3 productMask : 1
return dp[3][1] = 2

9) position : 2 productMask : 1
answer : 2
return dp[2][1] = 2

10) position : 1 productMask : 1
answer : 2
return dp[1][1] = 2

11) position : 0 productMask : 1
answer : 2
(answer + dfs(position + 1,
                    productMask | numsPrimeMask[position], numsPrimeMask, dp)) % MOD

12) position : 1 productMask : 5
dfs(position + 1, productMask, numsPrimeMask, dp)

13) position : 2 productMask : 5
dfs(position + 1, productMask, numsPrimeMask, dp)

14) position : 3 productMask : 5
dfs(position + 1, productMask, numsPrimeMask, dp)

15) position : 4 productMask : 5
return 1

16) position : 3 productMask : 5
answer : 1
(answer + dfs(position + 1,
                    productMask | numsPrimeMask[position], numsPrimeMask, dp)) % MOD;

17) position : 4 productMask : 13
return 1

18) position : 3 productMask : 5
return dp[3][5] = 2

19) position : 2 productMask : 5
answer : 2
return dp[2][5] = 2

20) position : 1 productMask : 5
answer : 2
return dp[1][5] = 2

21) position : 0 productMask : 1
answer : 4
return dp[0][1] = 4
 */
```