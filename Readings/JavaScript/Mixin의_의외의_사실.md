오늘은 2022년 10월 11일. 지시받은 대로 코드를 작성한 후 H 차장님한테 코드리뷰를 받았다. 코드리뷰를 받던 중 몰랐던 사실을 배웠다. 

우선 나는 중복되는 코드에 대해 Mixin을 사용했는데, 이런 디자인 패턴에 단점이 있다는 말씀을 들었다. 

찾아보니, Mixin이 Vue뿐만이 아니라 React에서도 사용되는 상당히 널리 사용되는 디자인 패턴이었다. (나는 프로젝트에 들어와서 사용되는 것을 보고, Vue에서만 사용되는 도구라 생각했다.)

페이스북에서 사용하는 리액트 코드가 점점 복잡해 지면서 개발자들이 이해하기 어렵게 여기고, 심지어 처음 작성한 사람도 이해하기 어려운 상태가 되었다. 그리고 이렇게 된 주요 원인은 Mixins였다.

컴포넌트는 mixin에 정의된 메서드에 의존하곤 한다. 내가 상태를 갖는 컴포넌트를 작성할 때, 동료가 이 상태를 읽는 mixin을 덧붙일 수 있다. 수개월 후에 내가 이 상태를 상위 컴포넌트로 옮길 수 있고, 자매 컴포넌트와 이 상태를 공유할 수 있다. 이때 mixin을 업데이트 해야 한다는 것을 기억할 수 있는가? 이런 묵시적 의존성은 새로운 팀 멤버가 코드베이스에 기여하기 어렵게 만든다. 컴포넌트에서 사용하지만 컴포넌트에 정의되어 있지 않은 메서드를 지워도 안전한가? 아마도 이 메서드는 mixin에 정의되어 있을텐데, 이 메서드를 찾으려면 mixin과 mixin의 mixin을 모두 다 뒤져야 한다.

여러 개의 mixin을 동시에 사용할 때, 이름의 충돌이 발생할 수 있다. 충돌이 발생하면, 한 개의 mixin에서 메서드의 이름을 바꿔야 한다. 그런데 이 mixin을 다른 mixin이나 다른 컴포넌트에서 사용하고 있다면? 이를 전부 뒤져서 수정해야 한다. 게다가 만약 third party package의 mixin에서 이름 충돌이 발생한다면? 현재 사용하는 컴포넌트의 메서드 명을 기이하게 수정해야 한다. 한번 작성하면, mixin들은 수정하거나 삭제하기가 매우 어렵고 위험하다.

mixin은 시작은 간단해도, 시간이 갈수록 복잡해 지는 경향이 있다. 새로운 필요에 의해 새로운 mixin이 추가되고, 처음 작성한 mixin의 내용을 호출해서 사용하게 된다. 수개월 후 새로운 기능이 덧붙이려 할때, 여러 개의 mixin이 너무 긴밀하게 연결되어 있는 것을 발견하게 된다.

CommentList와 BlogPost 컴포넌트는 동일하지 않고, 두 컴포넌트는 DataSource에서 서로 다른 메서드를 호출하며 다른 렌더링 결과를 보여준다고 가정하자. 하지만 대부분의 구현체는 동일하다. 이러한 경우에 고차 컴포넌트를 사용하면 좋다.

고차 컴포넌트는 입력된 컴포넌트를 수정하지 않으며 상속을 사용하여 동작을 복사하지도 않는다. 오히려 고차 컴포넌트는 원본 컴포넌트를 컨테이너 컴포넌트로 포장(Wrapping)하여 조합(compose)한다. 고차 컴포넌트는 사이드 이펙트가 전혀 없는 순수 함수.

하지만 mixin이 필요한 시점이 있다. mixin을 사용해야 한다면 https://v2.vuejs.org/v2/style-guide/#Private-property-names-essential 를 준수하자. 메서드의 이름을 지을 때, $_myGreatMixin_update와 같이 작명하는 방식.

코드를 작성하면서 기존에 작성되었던 코드의 일부를 그대로 사용했다. 객체를 반환할 때, Object로 반환하지 않고, {...Object}로 되어 있어서 이를 그대로 사용했는데, H 차장님이 이유를 물으셨다. 음.... 사실 깊게 생각하지 않고 그대로 사용했다... Object로 반환하면 얕은 참조가 일어나고, 반환받은 곳에서 객체를 수정하면, 이는 원본에 영향을 미친다. 반면 {...Object}로 반환하면 메모리에 새로 할당이 되고, 반환받은 곳에서 수정을 해도 원본에 영향이 없다. 하지만 내가 반환한 객체는 const로 정의되어 있고, 다시 수정되는 것을 걱정할 필요가 없어서, 연산상의 불리함을 감수하고 {...Object}로 반환할 이유가 없었다. 생각을 하자.

