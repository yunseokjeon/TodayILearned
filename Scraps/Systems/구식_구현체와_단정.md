C 언어가 기계에 가깝기 때문에 빠른 언어라는 식의 주장은 가소로운 것이다. malloc과 free를 쓰는 언어가 그런 주장을 해서는 안된다.

오후 4:36 · 2022년 8월 14일
·Twitter Web App

https://twitter.com/sanxiyn/status/1558719133843263488

malloc은 크기를 인자로 받는데 free는 포인터만 인자로 받고 크기를 인자로 받지 않는다. free는 도대체 메모리가 얼마나 할당되었는지 그 크기를 어떻게 아는 것일까?

오후 4:37 · 2022년 8월 14일
·Twitter Web App

https://twitter.com/sanxiyn/status/1558719419479511040

답은 C 런타임이 (C 런타임은 존재한다) 포인터에서 크기로 가는 룩업 테이블을 관리한다는 것이다. 이 룩업 테이블을 저장해야 하므로 불필요한 메모리 오버헤드가 발생하고, 이 룩업 테이블을 참조해야 하므로 불필요한 CPU 오버헤드가 발생한다.

오후 4:39 · 2022년 8월 14일
·Twitter Web App

https://twitter.com/sanxiyn/status/1558719967398223872

이러한 오버헤드는 포인터와 크기를 인자로 받는 free_sized 같은 API가 있었더라면 불필요한 것이다. 그렇다면 이러한 오버헤드가 무시할만큼 작은가? 그것도 아니다. 구글에 따르면 free_sized 대신 free를 써서 발생하는 CPU 오버헤드가 30%나 된다.

오후 4:42 · 2022년 8월 14일
·Twitter Web App

https://twitter.com/sanxiyn/status/1558720577849815040

이러한 이유 때문에 C 표준 위원회는 다음 버전의 C 표준에 free_sized를 추가하는 작업을 진행하고 있다. N2699를 보라. https://open-std.org/JTC1/SC22/WG14/www/docs/n2699.htm

오후 4:46 · 2022년 8월 14일
·Twitter Web App

https://twitter.com/sanxiyn/status/1558721752892551168

이러한 수정은 C++은 2014년에, Rust는 2018년에 이미 해결한 문제이다. C는 2022년까지도 이 문제를 해결하지 못하고 있다.

오후 4:48 · 2022년 8월 14일
·Twitter Web App

https://twitter.com/sanxiyn/status/1558722148507668480

<hr>

명백히 잘못된 말. 룩업테이블 없음. 할당된 메모리 주소에서 -x한 바이트(컴파일러따라 다르지만 보통 4~8)에 크기가 저장됨

그 걸 읽어오는 오버헤드는 있지만 룩업 테이블 같은 포인터 역참조 연산이 아니고 바로 옆 메모리 주소에 있어 캐시 메모리에 있어 매우 미미한 오버헤드뿐

오후 2:21 · 2022년 10월 11일
·Twitter Web App

https://twitter.com/BlindRendererKR/status/1579703687005769729

<hr>

일부 (비효율적인 구식) 구현체들만 보고서 이렇게 단정지으면 곤란. 현대적인 메모리 할당자 구현체들은 다양한 이유로 크기별 쓰레드 로컬 캐시를 사용하는 방향으로 설계가 수렴하고 있음.

오후 3:57 · 2022년 10월 11일
·Twitter Web App

https://twitter.com/summerlight00/status/1579727845844168704

이를테면 스트링 객체를 억 단위로 할당하고 해제한다고 가정하자. 원 트윗의 비효율적인 구현은 64비트 기준으로 모든 할당에 8바이트의 오버헤드가 추가되면서 수십 기가의 불필요한 메모리가 할당되는 것은 둘째치더라도 그로 인한 캐시 적중률의 저하는 측정 가능한 수준임이 보고됨

오후 3:57 · 2022년 10월 11일
·Twitter Web App

https://twitter.com/summerlight00/status/1579727847576711169

자신이 특정 분야에 전문가라고 자부한다면 더더욱 자신이 정확하게 이해하지 못하는 인근 분야에는 쓸데 없이 말을 얹지 않는 편이 좋겠음. "바로 옆 메모리 주소에 있어 미미한 오버헤드뿐"이라고 단정 짓기에는 그게 적용되지 않는 도메인이 수두룩하게 많다

오후 3:57 · 2022년 10월 11일
·Twitter Web App

https://twitter.com/summerlight00/status/1579727850198151168

4바이트 8바이트 존나 우스워보일지 모르지만 그런 객체가 수백만개 수천만개 올라가는 서버에서는 할당자의 구현에 따라 메모리 사용량이 10~20%씩 차이나는 것도 농담이 아닌 현실의 영역이 될 수 있음

오후 4:02 · 2022년 10월 11일
·Twitter Web App

https://twitter.com/summerlight00/status/1579729128009666560

내가 특정 영역에 장삼이사라고 한다면 무슨 헛소리를 하든 그걸 진지하게 들어줄 사람은 없으니 별 상관 없겠지만 나름 프로그래밍 교육업을 한다는 분이 저런 이야기를 하면 그걸 사실로 받아 들일 사람이 적지 않을 것.

오후 4:17 · 2022년 10월 11일
·Twitter Web App

https://twitter.com/summerlight00/status/1579732998446288899

