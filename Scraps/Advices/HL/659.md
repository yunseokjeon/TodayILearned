https://leetcode.com/problems/split-array-into-consecutive-subsequences/

일단 저 문제를 보고, 생각할 수 있는 방법은 동적 프로그래밍일거야. 뭔가 애매하면 동적프로그래밍부터 생각하는 거 같아. 근데 잘 알다시피 동적프로그래밍을 적용하기위한 조건이 있어. Subproblem이 곧 전체 문제해결로 가는 길이 되는거야. 하지만 이 문제를 보면 그 특성이 적용이 안된다는 걸 알거야. 예를들면 [3, 4]는 조건만족이 안되지만 [3, 4, 5] 는된다거나, [1, 2, 3, 3, 3, 4, 4, 5] 의 가능성을 알아보기위해 모든 가능한 subproblem 경우의 수로 나누고 들어가는게오히려 brute force에 준하는 복잡도로 귀결될 수 있단 말이지.
그래서 다른 가능한 방법들을 생각해보기 시작했어. 이럴때는 내가 아는 모든 자료구조와 알고리즘을 동원해 보는거야ㅋㅋ 그래프, 스택, 큐, 트리 등… 하지만 결과는 실패ㅠㅠ
그다음에 답지를 봤는데, 그러고 나니 뭔가 콜럼버스의 달걀처럼 깨달음이 왔어 ㅋㅋ 가장 강력한 메시지는 이미 소팅되어잇는 배열이라는 거야. 소팅이 됐단 얘기는 한번 스캔으로 끝나게 되는 경우가 많거든. 즉 O(N)이러는 얘기니까 저위에 내가 썼던 자료구조 중에는 머 해봤다 스택이나 큐? 가 그럴싸했네. 여기선 그리디 알고리즘을 썼더라고. 근데 내가 그리디가 안될거라 생각했던 이유는, 왼쪽부터 스캔할때 [1, 2, 3] 이 처음에 만들어지고 4를 다음으로 만났다고 치면 이걸새 시퀀스로 만들어야할지 아니면 기존 [1, 2, 3] 뒤에 붙여야할지 감이 안온다고 생각해서였어. 하지만 역시 답지는 그런 걱정들을 다 때려부수는구만..
답지중 가장 높은 vote를 받은 답안을 봤는데, 왼쪽부터 보면서 붙일 수 있는 걸 먼저 붙이고, 남는애들로 새 시퀀스를 꾸리더라고. 이게 우선순위가 명확하기때문에 그리디를 쓸 수가 있었어. 내가 위에서 하나의 element가 기존 시퀀스에 붙여야 할지 아니면 새 시퀀스를 만들어야할지에 대해 확실하게 정하지 못한다고 했잖아? 근데 linear scan으로 이 고민을해결해버리더라고… 리니어스캔의 경우 기존에 붙이는 거는 이전 시퀀스가 존재하는지 검사하는거 외에 제약사항이 하나도 없는 반면, 새 시퀀스를 만드는 건 다음 숫자들을 봐야한다는 제약사항이 있어서, 이전 시퀀스에 이어붙일 수 있으면 최대한 이어붙이는 선택을 하는게 무조건 유리하다는 결론이야…
난 면접에서 이런 문제 받으면 못풀듯 ㅠㅠ… 그래도 생각하는 과정이 다른 문제 푸는데에 도움이 됐기를 !
