```Java
class Box<T>{
    private T ob;
    public void set(T o){
        ob = o;
    }
    public T get(){
        return ob;
    }
}

/* 타입 매개변수의 이름 규칙
일반적인 관례 - 한 문자로 이름을 짓는다. 대문자로 이름을 짓는다.

보편적인 선택
E   Element
K   Key
N   Number
T   Type
V   Value
*/

// 제네릭 클래스의 타입 인자 제한하기
// 인스턴스 생성 시 타입 인자로 Number 또는 이를 상속하는 클래스만 올 수 있음
class Box<T extends Number>{
    private T ob;
    public void set(T o){
        ob = o;
    }
    public T get(){
        return ob;
    }
}

// 제네릭 클래스의 타입 인자를 인터페이스로 제한하기
interface Eatable{ public String eat(); }

class Apple implements Eatable{
    public String eat(){
        return "It tastes so good!";
    }
}

class Box<T extends Eatable>{
    T ob;

    public void set(T o){ ob = o; }
    public T get(){
        System.out.println(ob.eat()); // Eatable로 제한하였기에 eat 호출 가능
        return ob;
    }
}

// 제네릭 메소드의 정의
class BoxFactory{
    public static <T> Box<T> makeBox(T o){
        Box<T> box = new Box<T>();
        box.set(o);
        return box;
    }
}
```
```Java
class Box<T>{
    private T ob;
    public void set(T o){ ob = o; }
    public T get(){ return ob; }
}

class EmptyBoxFactory{
    public static <T> Box<T> makeBox(){
        Box<T> box = new Box<T>();
        return box;
    }
}

/*
main 메소드에서

Box<Integer> iBox = EmptyBoxFactory.<Integer>makeBox();

==

Box<Integer> iBox = EmptyBoxFactory.makeBox();

참조변수의 형 Box<Integer>를 기반으로 makeBox 메소드의 T를 결정하게 된다. 이를 가리켜 타겟 타입이라 한다.
*/
```
```Java
// 와일드 카드가 왜 필요한가?

// Box<Integer>의 인스턴스, Box<String>의 인스턴스를 인자로 전달 가능
public static <T> void peekBox(Box<T> box) {
   System.out.println(box);
}

// Box<Integer>의 인스턴스, Box<String>의 인스턴스를 인자로 전달 가능할 것 같지만 불가능
public static void peekBox(Box<Object> box) {
   System.out.println(box);
}

/*

"Box<Object>와 Box<String>은 상속 관계를 형성하지 않는다."
"Box<Object>와 Box<Integer>은 상속 관계를 형성하지 않는다."

그러나 와일드카드를 사용하면 일반 메소드도 이 두 인스턴스를 인자로 받을 수 있다.

*/

// Box<Integer>의 인스턴스, Box<String>의 인스턴스를 인자로 전달 가능
public static void peekBox(Box<?> box) {
   System.out.println(box);
}

```

```Java
// 상한 제한된 와일드카드(Upper-Bounded Wildcards)
public static void peekBox(Box<? extends Number> box) {
   System.out.println(box);
}

// 하한 제한된 와일드카드(Lower-Bounded Wildcards)
public static void peekBox(Box<? super Integer> box) {
   System.out.println(box);
}

/*
다음과 같이 정리하자!
Box<? extends Toy> box 대상으로 넣는 것 불가!
Box<? super Toy> box 대상으로 꺼내는 것 불가!
*/

// 와일드 카드 선언을 갖는 메소드를 제네릭으로
public static <T> void outBox(Box<? extends T> box) { ... }
// 꺼내는 것만 가능한 Box<T>

```

```Java
public static void main(String[] args){
    List<String> list = Arrays.asList("Toy", "Box", "Robot", "Weapon");
    list = new ArrayList<>(list);

    Collections.sort(list);
}

/*
Collections.sort(list); 이 부분을 보자.

1) ArrayList<String>이 인자로 전달된 것이다.

2) public static <T extends Comparable<T>> void sort(List<T> list) 이므로 T는 String으로 결정된다. 

3) 그런데 이 T는 Comparable<String>을 구현하고 있어야 한다.

4) class String extends Object implements Comparable<String>

구현하고 있다.
*/

/*
이제 다음 스텝.

public static <T extends Comparable<T>> void sort(List<T> list)  의 실제 모습은
public static <T extends Comparable<? super T>> void sort(List<T> list) 이다.

*/
```

