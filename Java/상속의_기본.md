상속의 매우 치명적인 오해 : 
상속은 코드의 재활용을 위한 문법이 아니라 "연관된 일련의 클래스들에 대해 공통적인 규약을 정의"하기 위함이다.

```Java 
// 적절한 생성자 정의의 예
class Man{
    String name;
    public Man(String name){
        this.name = name;
    }
    public void tellYourName(){
        System.out.println("My name is "  + name);
    }
}

class BusinessMan extends Man{
    String company;
    String position;

    public BusinessMan(String name, String company, String position){
        super(name);
        this.company = company;
        this.position = position;
    }

    public void tellYourInfo(){
        System.out.println("My company is " + company);
        System.out.println("My position is " + position);
        tellYourName();
    }
}
```
클래스 변수, 메소드는 상속이 되는가? 프로그램 전체에서 딱 하나만 존재하는데 상속의 대상이 되겠는가? 접근 수준 지시자에서 허용한다면 하위 클래스에서 이름만으로 접근 가능하다.

```Java 
// 오버라이딩 된 메소드 호출하는 방법
class Cake{
    public void yummy(){
        System.out.println("Yummy Cake");
    }
}

class CheeseCake extends Cake{
    public void yummy(){
        super.yummy();
        System.out.println("Yummy Cheese Cake");
    }
}

// 오버라이딩 된 메소드를 인스턴스 외부에서 호출하는 방법은 없다. 그러나 인스턴스 내부에서는 키워드 super를 이용해 호출 가능.
```

인스턴스 변수와 클래스 변수도 오버라이딩 되는가? 인스턴스 변수는 오버라이딩 되지 않는다. 따라서 참조변수의 형에 따라 접근하는 멤버가 결정된다.

```Java 
if(ref instanceof ClassName)
// ref가 ClassName 클래스의 인스턴스를 참조하면 true 반환
// ref가 ClassName를 상속하는 클래스의 인스턴스이면 true 반환
```
```Java 
// 클래스와 메소드의 final 선언
public final class MyLastCLS{...}
// MyLastCLS 클래스는 다른 클래스가 상속할 수 없음

class Simple{
    public final void func(int n){...}
    // 이 메소드는 다른 클래스에서 오버라이딩 할 수 없음
}
```
